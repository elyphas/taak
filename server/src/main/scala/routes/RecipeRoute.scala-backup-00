package server_routes

import org.http4s._
import org.http4s.dsl.io._
import shared.mytypes.Recipe
//import org.http4s.circe.CirceEntityCodec.circeEntityEncoder
import org.http4s.circe._
import io.circe.generic.auto._
//import io.circe.syntax._
import io.circe.literal._
import cats.effect._
//import cats.effect.unsafe.implicits.global
import org.http4s.circe.CirceEntityDecoder.circeEntityDecoder

import scala.concurrent.ExecutionContext

object RecipeRoute {

    //type EncodeMyType = (Double,  List[(QryRow, Comparative)], ViewProcess)

    //implicit val bodyPostEncode: EntityEncoder[IO, Recipe] = jsonEncoderOf

    val route = HttpRoutes.of[IO] {
                 case request @ POST -> Root / "recipe" =>

                      //implicit val ec: ExecutionContext =  scala.concurrent.ExecutionContext.Implicits.global

                      val res = for {
                          req <- circeEntityDecoder[IO, Recipe].decode(request, strict = true).value
                          idCompar <- IO(req.getOrElse(""))
                          comparativo <- getComparativo.calculateComparative(idCompar)
                          minimosRetensISR <- getMinimosRetensionISR.run(idCompar)
                          process <- getProcess.byId(ViewProcess(id_comparativo = idCompar))
                      } yield {
                           val result = for {
                              isr <- minimosRetensISR
                              compar <- comparativo
                              (proc, event) <- process
                          } yield (isr.asJson, compar.asJson, proc.asJson)

                        result.fold(l => NotFound(l.getMessage), r => Ok(r))
                      }

                     res.flatten

            }
            
}