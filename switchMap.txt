  //val onSearchReporte = PublishSubject[String]()
  // for each new value in onSearch, currentProvider will switch to the next emitted Observable. So if there are two pending ajax request
  // from two suceeding triggers, always the last one will win.
  //val currentProvider = onSearch.switchMap { id =>
  //  Observable.fromFuture(AjaxClient[Api.searchIdProvveedor(id).call())
  //}
  // Then derive your `txt*` observables:
  //val txtDescription = onSearch.map(_.description.getOrElse("")) // and so on

  //@elyphas what i forgot to say yesterday: you should define your currentProvider as a multicast observable, so that
  // multiple subscribtions do not all trigger a ajax request each (just add .share):

  //val currentProvider = onSearchProveedor.switchMap { descripcion =>
  //  Observable.fromFuture(AjaxClient[Api].searchProveedor(descripcion).call())
  //}.share

  //But that does not help with your problem right now. But I have to admit, I am not sure why it does not work right now on first glance.
  //have you subscribed to your store? otherwise the reducing will never be triggered: just do store.foreach(s => println("Store updated: " + s)


  What would be the problem with this?

  val onSearch = PublishSubject[String]()

  // for each new value in onSearch, currentProvider will switch to the next emitted Observable.
  // So if there are two pending ajax request from two suceeding triggers, always the last one will win.
  val currentProvider = onSearch.switchMap { descripcion =>
    Observable.fromFuture( AjaxClient[ Api ].searchProveedor( descripcion ).call( ) )
  }.share

  currentProvider.map { prov =>
    SearchProveedor ( prov )
  }.subscribe( store )

  store.foreach { p =>
    println ( "El store" )
    println ( p )
  }

  val onClickItem = Sink.create[String] { id: String =>
    Future {
      store.foreach { s =>
        println( "En el store" )
        println( s )
      }
      Continue
    }
  }

  because the onClickItem the foreach prints an empty list.
    the store is of type outwatch.util.Store
  and the state is this: case class State( lst: Seq[ Proveedor ] )
  the outer store.foreach prints the results
    johannes karoff
  @cornerman
  Jan 25 14:11
  You are subscribing to the store on each item you get into the onClickItem sink. Now, the store currently does not store the last emitted value like a behaviour or replay subject. it just always starts with the initial state (we are working on an improvement OutWatch/outwatch#270). Be aware that you are creating way to many subscriptions this way, because every emitted item will create another subscription to store and you will many in the end.
    elyphas
  @elyphas
  Jan 25 14:19
  @cornerman ; ok thank you
  johannes karoff
  @cornerman
  Jan 25 14:36
  what do you want to achieve?
  elyphas
  @elyphas
  Jan 25 14:54

  @cornerman ; I want to create a grid makes with div's

  div(
    div("item1", onClick -->SelectItem&UpdateTextBoxes),
    div("item2", onClick -->SelectItem&UpdateTextBoxes),
  ....
  )

  and when click on any of them filter the original list a choice the right one and then update the textBoxes
  This is my full code: https://gist.github.com/elyphas/3146d52b46238a93a9c646c50276e822
  to be precise in the line 41 I want to update the textBoxes
  The grid with div's is already working very good, :)
  johannes karoff
  @cornerman
  Jan 25 15:00
  I think, you could simplify your code a lot if you would have a data class to represent your txt handler case class Txt(rfx: String, description: String, ...).
  than you would just need one Handler
  elyphas
  @elyphas
  Jan 25 15:02
  my case class Proveedor is this:

  case class Proveedor(
                        id: String = "",
                        descripcion: Option[String] = None,
                        propietario: Option[String] = None,
                        calle: Option[String] = None,
                        colonia: Option[String] = None,
                        delegacion: Option[String] = None,
                        cp: Option[String] = None,
                        ciudad: Option[String] = None,
                        telefonos: Option[String] = None,
                        fax: Option[String] = None,
                        observaciones: Option[String] = None,
                        activo: Boolean = true,
                        elaboro: Option[String] = None,
                        giro: Option[String] = None,
                        descuento: Option[String] = None) extends Father

  johannes karoff
  @cornerman
  Jan 25 15:02
  for your components later you would one handler and then map it to the right part of the case class: handler.map(_.rfc), handler.map(_.description), and so on
  elyphas
  @elyphas
  Jan 25 15:03
  I think about that but

  this:

  val currentProvider = onSearch.switchMap { descripcion =>
    Observable.fromFuture( AjaxClient[ Api ].searchProveedor( descripcion ).call( ) )
  }.share

  returns a Seq[Proveedor]
  I don't know how to filter to make one proveedor a update like you just said.
  with the click
    I am thinking that I need a var lstProveedor : Seq[Proveedor] to query in the future.
  johannes karoff
  @cornerman
  Jan 25 15:08

  then just keep that and create one Handler[Proveedor]. you do not really need to have a single handler for each part of it. you can create a sink that will zoom into the case class, for example:

    something like this should work and we should have a helper for that:

  case class Data(number: Int, text: String)
  val handler = PublishSubject[Data]

  div(
    onInput.value.transform(_.withLatestFrom(handler)((txt, data) => data.copy(txt = data))) --> handler
  )

  by using withLatestFrom you are essential replacing your var lstProveedor (to keep the current state) by an observable operation that combines the latest value when emitting a new onClick event
    elyphas
  @elyphas
  Jan 25 15:10
  ah ok, I am going to try, thank you
    johannes karoff
  @cornerman
  Jan 25 15:11
  onClick was a bad example, it would need an event that emits a string, like onInput.value.transform.... or if you have a constant, you can simply do: onClick(handler).map(_.copy(txt = "newTxt")) --> handler
  elyphas
  @elyphas
  Jan 25 15:12
  ok
  elyphas
  @elyphas
  Jan 25 15:37
  @cornerman; sorry,
  I got troubles with a component :

  val handlerProveedor = PublishSubject[Proveedor]

  val txtRFC = handlerProveedor.map( _.id ) //Handler.create[String]("").unsafeRunSync()

  //def component( lbl: String, h: ProHandler[ String, String ] ): VNode = {
  def component( lbl: String, h: PublishSubject[String] ): VNode = {
    div( //width:="500px",
      label( lbl, backgroundColor:="gray", fontWeight := 10, marginRight:="10px" ),
      input( inputString --> h, value <-- h, marginRight := "20" )
    )
  }
  component( "R.F.C.", txtRFC ),

  Type mismatch, expected: PublishSubject[String], actual: Observable[String]

  johannes karoff
  @cornerman
  Jan 25 15:52
  Yeah, fair enough. The map only creates an observable. We have the method .lens for handlers and subjects (https://github.com/OutWatch/outwatch/blob/master/outwatch/src/main/scala/outwatch/MonixOps.scala#L72). That allows to map the observable as well as observer part of a handler. But it is not that easy to use, because for the observer to works, it needs to be subscribed. So you could do:

  val txtRFC: Handler[String] = handlerProveedor.lens[String](Proveedor.initial)( _.id )((proveedor, id) => proveedor.copy(id = id))
  val cancelable = txtRFC.connect() // need to subscribe to this handler, because it internally needs to track the current state.

  elyphas
  @elyphas
  Jan 25 15:58
  @cornerman , ok thank you
  Moritz Bust
  @Busti
  Jan 25 16:08
  @cornerman I was able to reproduce the weird test-case in Store in a fiddle. I am going to post it to the monix channel now.
    https://scalafiddle.io/sf/7tgDepe/0
  Moritz Bust
  @Busti
  Jan 25 17:04
  It looks like I effed up my PR. I am sorry. I hope it is okay to squash this. I can try to repair the damage, but I would probably fail miserable.
  Moritz Bust
  @Busti
  Jan 25 17:35
  I am so sorry. I always seem to fail rebasing a branch. I am still very much learning git and this is my first time making any significant contributions to an open source project.
  Moritz Bust
  @Busti
  Jan 25 19:13
  Nevermind. I have just learned that that is exactly what is supposed to happen
  Moritz Bust
  @Busti
  Jan 25 19:33
  @cornerman Also, I have found a solution for the problem from earlier, which I will push later tomorrow.
  I can then squash that PR and rebase it again, so that it is ready to be merged. Afaik, there are no other topics that are open for that PR.
